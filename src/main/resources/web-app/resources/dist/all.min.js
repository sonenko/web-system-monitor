angular.module("app", [
  "ngRoute",
  "angular-loading-bar",
  "ngAnimate",
  'ngTouch',
  "ngResource",
  "ui.grid",
  "ui.grid.edit",
  "ui.grid.selection",
  "ui.grid.rowEdit",
  "ui.grid.cellNav"])
  .config(["$routeProvider", function ($routeProvider) {
    var rootFolder = "src/app/";

    $routeProvider
      .when("/processes", {
        templateUrl: rootFolder + "views/processes.html",
        controller: "ProcessesCtrl"
      })
      .when("/configuration", {
        templateUrl: rootFolder + "views/configuration.html",
        controller: "ConfigurationCtrl"
      })
      .otherwise({
        redirectTo: "/processes"
      });
  }])

  .controller("AppCtrl", ["$scope", "$interval", "$location",
    function ($scope, $interval, $location) {
      // pages
      $scope.isProcessesPage = function () {
        return $location.path().substring(1) === "processes"
      };

      $scope.isConfigurationPage = function () {
        return $location.path().substring(1) === "configuration"
      };

      // to stop asking server for new data if page changed
      $scope.intervals = [];
      $scope.watchInterval = function (interval) {$scope.intervals.push(interval);};
      $scope.cancelPrevIntervals = function () {
        _.forEach($scope.intervals, function (interval) {
          $interval.cancel(interval);
        });
        $scope.intervals = [];
      };

      //
      $scope.gridDynConfig = {
        maxCpu: 10,
        refreshRate: 2000
      };
    }]);

angular.module("app")
  .controller("ProcessesCtrl", function ($scope, ProcessesService, $interval, uiGridConstants) {

    $scope.gridDynConfig.maxCpu = parseInt($scope.gridDynConfig.maxCpu, 10);
    $scope.data = [];
    $scope.gridOptions = {
      enableFiltering: true,
      multiSelect: false,
      noUnselect: true,
      enableRowSelection: true,
      enableRowHeaderSelection: false,
      columnDefs: [
        {field: 'taskName', displayName: 'Task', enableCellEdit: false},
        {field: 'pid', displayName: 'PID', enableCellEdit: false},
        {field: 'user', displayName: 'User', enableCellEdit: false},
        {field: 'cpu', displayName: 'Processor %', enableCellEdit: false,
          cellClass: function(grid, row, col, rowRenderIndex, colRenderIndex) {
            if (grid.getCellValue(row, col) > $scope.gridDynConfig.maxCpu) return 'red';
          }
        },
        {field: 'memory', displayName: 'Memory %', enableCellEdit: false},
        {field: 'description', displayName: 'Command', enableCellEdit: false}
      ],
      sortInfo: {
        fields: ['cpu'],
        directions: ['desc']
      },
      data: $scope.data
    };

    $scope.gridOptions.onRegisterApi = function(gridApi){
      $scope.gridApi = gridApi;
      gridApi.selection.on.rowSelectionChanged($scope,function(row){
        var msg = 'row selected ' + row.isSelected;
        selectedPid = row.entity.pid;
        $scope.enableKill = true;
      });
    };


    $scope.killProcess = function () {
      ProcessesService.kill(selectedPid, function () {
        $scope.enableKill = false;
        selectedPid = undefined;
      });
    };

    //
    var selectedPid = undefined;
    $scope.enableKill = false;
    //
    function refresh() {
      ProcessesService.processes(function (data) {
        $scope.gridOptions.data = data;
        if (selectedPid) {
          $interval( function() {
            var selectedRow = _.find(data, function (v) {return v.pid === selectedPid});
            $scope.gridApi.selection.selectRow(selectedRow);
          }, 0, 1);
        }
      });
    }
    refresh();
    var interval = $interval(refresh, parseInt($scope.gridDynConfig.refreshRate, 10));
    $scope.cancelPrevIntervals();
    $scope.watchInterval(interval);
  })

  .controller("ConfigurationCtrl", function ($scope) {
    $scope.cancelPrevIntervals();

    $scope.options = [
      {value: 1000, name: "1 sec"},
      {value: 2000, name: "2 sec"},
      {value: 10000, name: "10 sec"},
      {value: 60000, name: "1 min"}
    ];

  });

angular.module("app")
  .factory("ProcessesService", function ($http) {
    return {
      processes: function (fn) {
        $http.get("/api/info")
          .success(fn)
          .error(function (error) {console.error("there was server error: " + error)});
      },
      kill: function (pid, fn) {
        $http.post("/api/kill/" + pid, {})
          .success(fn)
          .error(function (error) {console.error("there was server error: " + error)});
      }
    }
  });

//# sourceMappingURL=all.min.js.map